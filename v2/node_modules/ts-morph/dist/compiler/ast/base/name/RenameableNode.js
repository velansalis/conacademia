"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const errors = require("../../../../errors");
const utils_1 = require("../../../../utils");
const manipulation_1 = require("../../../../manipulation");
function RenameableNode(Base) {
    return class extends Base {
        rename(newName, options) {
            const languageService = this._context.languageService;
            renameNode(getNodeToRename(this));
            return this;
            function getNodeToRename(thisNode) {
                if (utils_1.TypeGuards.isIdentifier(thisNode))
                    return thisNode;
                else if (thisNode.getNameNode != null) {
                    const node = thisNode.getNameNode();
                    errors.throwIfNullOrUndefined(node, "Expected to find a name node when renaming.");
                    if (utils_1.TypeGuards.isArrayBindingPattern(node) || utils_1.TypeGuards.isObjectBindingPattern(node))
                        throw new errors.NotImplementedError(`Not implemented renameable scenario for ${node.getKindName()}.`);
                    return node;
                }
                else
                    throw new errors.NotImplementedError(`Not implemented renameable scenario for ${thisNode.getKindName()}`);
            }
            function renameNode(node) {
                errors.throwIfWhitespaceOrNotString(newName, "newName");
                if (node.getText() === newName)
                    return;
                const renameLocations = languageService.findRenameLocations(node, options);
                const renameLocationsBySourceFile = new utils_1.KeyValueCache();
                for (const renameLocation of renameLocations) {
                    const locations = renameLocationsBySourceFile.getOrCreate(renameLocation.getSourceFile(), () => []);
                    locations.push(renameLocation);
                }
                for (const [sourceFile, locations] of renameLocationsBySourceFile.getEntries()) {
                    manipulation_1.replaceSourceFileTextForRename({
                        sourceFile,
                        renameLocations: locations,
                        newName
                    });
                }
            }
        }
    };
}
exports.RenameableNode = RenameableNode;
