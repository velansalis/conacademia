"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_1 = require("../../typescript");
const utils_1 = require("../../utils");
const helpers_1 = require("../helpers");
const nodeHandlers_1 = require("../nodeHandlers");
const textManipulators_1 = require("../textManipulators");
const doManipulation_1 = require("./doManipulation");
/**
 * Inserts a text range into a parent.
 */
function insertIntoParentTextRange(opts) {
    const { insertPos, newText, parent } = opts;
    // todo: this should only forget the existing node if the kind changes
    doManipulation_1.doManipulation(parent._sourceFile, new textManipulators_1.InsertionTextManipulator({
        insertPos,
        newText,
        replacingLength: opts.replacing == null ? undefined : opts.replacing.textLength
    }), new nodeHandlers_1.NodeHandlerFactory().getForParentRange({
        parent,
        start: insertPos,
        end: insertPos + newText.length,
        replacingLength: opts.replacing == null ? undefined : opts.replacing.textLength,
        replacingNodes: opts.replacing == null ? undefined : opts.replacing.nodes,
        customMappings: opts.customMappings
    }));
}
exports.insertIntoParentTextRange = insertIntoParentTextRange;
/**
 * Inserts a text range into a source file.
 */
function insertIntoTextRange(opts) {
    const { insertPos, newText, sourceFile } = opts;
    doManipulation_1.doManipulation(sourceFile, new textManipulators_1.InsertionTextManipulator({
        insertPos,
        newText
    }), new nodeHandlers_1.NodeHandlerFactory().getForRange({
        sourceFile,
        start: insertPos,
        end: insertPos + newText.length
    }));
}
exports.insertIntoTextRange = insertIntoTextRange;
function insertIntoCommaSeparatedNodes(opts) {
    // todo: this function could use a bit of clean up
    const { currentNodes, insertIndex, parent } = opts;
    const previousNode = currentNodes[insertIndex - 1];
    const previousNonCommentNode = getPreviousNonCommentNode();
    const nextNode = currentNodes[insertIndex];
    const nextNonCommentNode = getNextNonCommentNode();
    const separator = opts.useNewLines ? parent._context.manipulationSettings.getNewLineKindAsString() : " ";
    const parentNextSibling = parent.getNextSibling();
    const isContained = parentNextSibling != null && (parentNextSibling.getKind() === typescript_1.SyntaxKind.CloseBraceToken || parentNextSibling.getKind() === typescript_1.SyntaxKind.CloseBracketToken);
    let { newText } = opts;
    if (previousNode != null) {
        prependCommaAndSeparator();
        if (nextNonCommentNode != null)
            appendCommaAndSeparator();
        else if (opts.useNewLines || opts.surroundWithSpaces)
            appendSeparator();
        else
            appendIndentation();
        const nextEndStart = nextNode == null ? (isContained ? parentNextSibling.getStart(true) : parent.getEnd()) : nextNode.getStart(true);
        const insertPos = (previousNonCommentNode || previousNode).getEnd();
        insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: { textLength: nextEndStart - insertPos }
        });
    }
    else if (nextNode != null) {
        if (opts.useNewLines || opts.surroundWithSpaces)
            prependSeparator();
        if (nextNonCommentNode == null)
            appendSeparator();
        else
            appendCommaAndSeparator();
        const insertPos = isContained ? parent.getPos() : parent.getStart(true);
        insertIntoParentTextRange({
            insertPos,
            newText,
            parent,
            replacing: { textLength: nextNode.getStart(true) - insertPos }
        });
    }
    else {
        if (opts.useNewLines || opts.surroundWithSpaces) {
            prependSeparator();
            appendSeparator();
        }
        else
            appendIndentation();
        insertIntoParentTextRange({
            insertPos: parent.getPos(),
            newText,
            parent,
            replacing: { textLength: parent.getNextSiblingOrThrow().getStart() - parent.getPos() }
        });
    }
    function prependCommaAndSeparator() {
        if (previousNonCommentNode == null) {
            prependSeparator();
            return;
        }
        const originalSourceFileText = parent.getSourceFile().getFullText();
        const previousNodeNextSibling = previousNonCommentNode.getNextSibling();
        let text = "";
        if (previousNodeNextSibling != null && previousNodeNextSibling.getKind() === typescript_1.SyntaxKind.CommaToken) {
            appendNodeTrailingCommentRanges(previousNonCommentNode);
            text += ",";
            if (previousNonCommentNode === previousNode)
                appendNodeTrailingCommentRanges(previousNodeNextSibling);
            else
                appendCommentNodeTexts();
        }
        else {
            text += ",";
            if (previousNonCommentNode === previousNode)
                appendNodeTrailingCommentRanges(previousNonCommentNode);
            else
                appendCommentNodeTexts();
        }
        prependSeparator();
        newText = text + newText;
        function appendCommentNodeTexts() {
            const lastCommentRangeEnd = getLastCommentRangeEnd(previousNode) || previousNode.getEnd();
            text += originalSourceFileText.substring(previousNonCommentNode.getEnd(), lastCommentRangeEnd);
        }
        function appendNodeTrailingCommentRanges(node) {
            const lastCommentRangeEnd = getLastCommentRangeEnd(node);
            if (lastCommentRangeEnd == null)
                return;
            text += originalSourceFileText.substring(node.getEnd(), lastCommentRangeEnd);
        }
        function getLastCommentRangeEnd(node) {
            const commentRanges = node.getTrailingCommentRanges();
            const lastCommentRange = commentRanges[commentRanges.length - 1];
            return lastCommentRange == null ? undefined : lastCommentRange.getEnd();
        }
    }
    function getPreviousNonCommentNode() {
        for (let i = insertIndex - 1; i >= 0; i--) {
            if (!utils_1.TypeGuards.isCommentNode(currentNodes[i]))
                return currentNodes[i];
        }
        return undefined;
    }
    function getNextNonCommentNode() {
        for (let i = insertIndex; i < currentNodes.length; i++) {
            if (!utils_1.TypeGuards.isCommentNode(currentNodes[i]))
                return currentNodes[i];
        }
        return undefined;
    }
    function prependSeparator() {
        if (!utils_1.StringUtils.startsWithNewLine(newText))
            newText = separator + newText;
    }
    function appendCommaAndSeparator() {
        newText = helpers_1.appendCommaToText(newText);
        appendSeparator();
    }
    function appendSeparator() {
        if (!utils_1.StringUtils.endsWithNewLine(newText))
            newText += separator;
        appendIndentation();
    }
    function appendIndentation() {
        if (opts.useNewLines || utils_1.StringUtils.endsWithNewLine(newText)) {
            if (nextNode != null)
                newText += parent.getParentOrThrow().getChildIndentationText();
            else
                newText += parent.getParentOrThrow().getIndentationText();
        }
    }
}
exports.insertIntoCommaSeparatedNodes = insertIntoCommaSeparatedNodes;
/**
 * Used to insert non-comma separated nodes into braces or a source file.
 */
function insertIntoBracesOrSourceFile(opts) {
    const { parent, index, children } = opts;
    const fullText = parent._sourceFile.getFullText();
    const insertPos = helpers_1.getInsertPosFromIndex(index, parent.getChildSyntaxListOrThrow(), children);
    const endPos = helpers_1.getEndPosFromIndex(index, parent, children, fullText);
    const replacingLength = endPos - insertPos;
    const newText = getNewText();
    doManipulation_1.doManipulation(parent._sourceFile, new textManipulators_1.InsertionTextManipulator({ insertPos, replacingLength, newText }), new nodeHandlers_1.NodeHandlerFactory().getForParentRange({
        parent: parent.getChildSyntaxListOrThrow(),
        start: insertPos,
        end: insertPos + newText.length,
        replacingLength
    }));
    function getNewText() {
        // todo: make this configurable
        const writer = parent._getWriterWithChildIndentation();
        opts.write(writer, {
            previousMember: getChild(children[index - 1]),
            nextMember: getChild(children[index]),
            isStartOfFile: insertPos === 0
        });
        return writer.toString();
        function getChild(child) {
            // ensure it passes the implementation
            if (child == null)
                return child;
            else if (utils_1.TypeGuards.isOverloadableNode(child))
                return child.getImplementation() || child;
            else
                return child;
        }
    }
}
exports.insertIntoBracesOrSourceFile = insertIntoBracesOrSourceFile;
/**
 * Glues together insertIntoBracesOrSourceFile and getRangeFromArray.
 * @param opts - Options to do this operation.
 */
function insertIntoBracesOrSourceFileWithGetChildren(opts) {
    if (opts.structures.length === 0)
        return [];
    const startChildren = opts.getIndexedChildren();
    const parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();
    const index = helpers_1.verifyAndGetIndex(opts.index, startChildren.length);
    insertIntoBracesOrSourceFile({
        parent: opts.parent,
        index: getChildIndex(),
        children: parentSyntaxList.getChildren(),
        write: opts.write
    });
    return helpers_1.getRangeWithoutCommentsFromArray(opts.getIndexedChildren(), opts.index, opts.structures.length, opts.expectedKind);
    function getChildIndex() {
        if (index === 0)
            return 0;
        // get the previous member in order to get the implementation signature + 1
        return startChildren[index - 1].getChildIndex() + 1;
    }
}
exports.insertIntoBracesOrSourceFileWithGetChildren = insertIntoBracesOrSourceFileWithGetChildren;
function insertIntoBracesOrSourceFileWithGetChildrenWithComments(opts) {
    const startChildren = opts.getIndexedChildren();
    const parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();
    const index = helpers_1.verifyAndGetIndex(opts.index, startChildren.length);
    insertIntoBracesOrSourceFile({
        parent: opts.parent,
        index: getChildIndex(),
        children: parentSyntaxList.getChildren(),
        write: opts.write
    });
    return helpers_1.getNodesToReturn(startChildren, opts.getIndexedChildren(), index, true);
    function getChildIndex() {
        if (index === 0)
            return 0;
        // get the previous member in order to get the implementation signature + 1
        return startChildren[index - 1].getChildIndex() + 1;
    }
}
exports.insertIntoBracesOrSourceFileWithGetChildrenWithComments = insertIntoBracesOrSourceFileWithGetChildrenWithComments;
