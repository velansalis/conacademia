"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const Printer_1 = require("../Printer");
const appendCommaToText_1 = require("../../manipulation/helpers/appendCommaToText");
class CommaSeparatedStructuresPrinter extends Printer_1.Printer {
    constructor(printer) {
        super();
        this.printer = printer;
    }
    printText(writer, structures) {
        printTextWithSeparator(this.printer, writer, structures, () => writer.spaceIfLastNot());
    }
}
exports.CommaSeparatedStructuresPrinter = CommaSeparatedStructuresPrinter;
function printTextWithSeparator(printer, writer, structures, separator) {
    if (structures == null)
        return;
    if (structures instanceof Function || typeof structures === "string")
        printer.printText(writer, structures);
    else {
        // insert all the texts first
        const commaAppendPositions = new Array(structures.length);
        for (let i = 0; i < structures.length; i++) {
            if (i > 0)
                separator();
            const structure = structures[i];
            const startPos = writer.getLength();
            printer.printText(writer, structure);
            // collect the comma append position for this text
            const pos = appendCommaToText_1.getAppendCommaPos(utils_1.WriterUtils.getLastCharactersToPos(writer, startPos));
            commaAppendPositions[i] = pos === -1 ? false : pos + startPos;
        }
        // now insert the commas as necessary
        let foundFirst = false;
        for (let i = commaAppendPositions.length - 1; i >= 0; i--) {
            const pos = commaAppendPositions[i];
            if (pos === false)
                continue;
            else if (!foundFirst)
                foundFirst = true;
            else
                writer.unsafeInsert(pos, ",");
        }
    }
}
exports.printTextWithSeparator = printTextWithSeparator;
